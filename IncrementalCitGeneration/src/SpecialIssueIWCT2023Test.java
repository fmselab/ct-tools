import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;

import org.junit.Test;

import ctwedge.ctWedge.CitModel;
import ctwedge.generator.acts.ACTSTranslator;
import ctwedge.generator.exporter.CSVExporter;
import ctwedge.generator.pict.PICTGenerator;
import ctwedge.util.TestSuite;
import ctwedge.util.ext.Utility;
import ctwedge.util.smt.SMTTestSuiteValidator;
import pMedici.main.PMedici;
import pMedici.util.Order;
import pMedici.util.TestContext;

public class SpecialIssueIWCT2023Test {

	static int N_REP = 5;
	static String PATH = "examples/SI_IWCT_2023_MODELS/";
	static int[] PERCENTAGE_REMOVAL = { 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };
	static String TEMP_FILE_NAME = "temp.txt";
	static int TIMEOUT_MS = 300000;
	static int STRENGTH = 2;

	/**
	 * Test executor for the TSCP Scenario.
	 * 
	 * It executes the tests with: - ACTS (without seeds) - ACTS (with seeds) -
	 * pMEDICI (without seeds) - pMEDICI+ (with seeds) - PICT (with seeds) - PICT
	 * (without seeds)
	 * 
	 * First a complete test suite is generated by ACTS, then seeds are created from
	 * that test suite and partially removing a percentage of test cases
	 * 
	 * @throws Exception
	 */
	@Test
	public void testTSCP() throws Exception {
		File folder = new File(PATH);
		File[] listOfFiles = folder.listFiles();
		Arrays.sort(listOfFiles, new Comparator<File>() {
			@Override
			public int compare(File o1, File o2) {
				return o1.getName().compareTo(o2.getName());
			}
		});
		String timeStamp = new SimpleDateFormat("yyyy.MM.dd.HH.mm").format(new java.util.Date());
		String output_file = "resultsTSCP_"+ timeStamp + ".csv";

		// File header
		printFileHeader(output_file);

		// Configurations
		TestContext.IN_TEST = true;

		for (File f : listOfFiles) {
			if (!f.getAbsolutePath().endsWith(".ctw") || !f.getName().contains("MCAC_9"))
				continue;

			// Repeat the experiments N_REP times
			for (int i = 0; i < N_REP; i++) {

				// Generate test suite with ACTS
				TestSuite ts1 = null;
				try {
					ts1 = getACTSTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH, null);
					printStats(ts1, 0, STRENGTH, output_file, null);
					Thread.sleep(200);
				} catch (Error e) {
					System.err.println(e.getMessage());
					continue;
				}

				// Proceed only if seeds have been generated
				if (ts1.getGeneratorTime() != -1) {
					// Remove a percentage of test cases and define a new test suite
					for (int percentage : PERCENTAGE_REMOVAL) {
						// Define the seeds
						TestSuite tsTemp;
						TestSuite tsTempPICT;
						TestSuite tsTempACTS;
						List<ctwedge.util.Test> tempTsActs = selectRandomSeeds(Utility.loadModelFromPath(f.getAbsolutePath()), ts1, percentage);
						if (tempTsActs.size() > 0)
							tsTemp = new TestSuite(toCSVcode(tempTsActs), Utility.loadModelFromPath(f.getAbsolutePath()), ",");
						else
							tsTemp = null;

						// Try with PICT
						tsTempPICT = getPICTTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH, tsTemp);
						printStats(tsTempPICT, percentage, STRENGTH, output_file, null);
						Thread.sleep(200);

						// Try with ACTS by feeding a seed test suite
						tsTempACTS = getACTSTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH, tsTemp);
						printStats(tsTempACTS, percentage, STRENGTH, output_file, null);
						Thread.sleep(200);

						// Try with pMEDICI and pMEDICI+ with multiple ordering strategies
						getAllPMediciTestSuites(output_file, f, percentage, tempTsActs);
					}
				}
			}
		}
	}

	/**
	 * Prints the header of the output file
	 * 
	 * @param output_file the name of the output file
	 * @throws IOException
	 */
	private void printFileHeader(String output_file) throws IOException {
		FileWriter fw = new FileWriter(output_file, true);
		BufferedWriter bw = new BufferedWriter(fw);
		bw.write("Generator,ModelName,PercentageOfOldTsKept,TSSize,TSTime,Strength,Ordering,");
		bw.newLine();
		bw.close();
	}

	/**
	 * Returns a test suite generated with ACTS
	 * 
	 * @param model    the CIT Model
	 * @param strength the strength
	 * @param seed     the test suite to be used as seeds. It can be null if no
	 *                 seeds have to be used
	 * @return a test suite generated with ACTS
	 */
	private TestSuite getACTSTestSuite(CitModel model, int strength, TestSuite seed) {
		TestSuite ts1;
		ExecutorService executor = Executors.newCachedThreadPool();
		Callable<TestSuite> task = new Callable<TestSuite>() {
			public TestSuite call() throws Exception {
				ACTSTranslator actsTranslator = new ACTSTranslator();
				TestSuite ts1 = actsTranslator.getTestSuite(model, strength, false, seed);
				ts1.setGeneratorName("ACTS");
				return ts1;
			}
		};
		Future<TestSuite> future = executor.submit(task);
		try {
			ts1 = future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
		} catch (TimeoutException | InterruptedException | ExecutionException ex) {
			ts1 = new TestSuite(model, null);
			ts1.setGeneratorName("ACTS");
			ts1.setGeneratorTime(-1);
		} finally {
			// May or may not desire this
			future.cancel(true);
		}
		return ts1;
	}

	/**
	 * Given a test suite, a model and a percentage of test cases to be removed, it
	 * randomly selects a list of test cases
	 * 
	 * @param model      the CIT Model
	 * @param ts1        the test suite from which test cases need to be extracted
	 * @param percentage the percentage of tests to be removed
	 * @return a list of Tests
	 */
	private List<ctwedge.util.Test> selectRandomSeeds(CitModel model, TestSuite ts1, int percentage) {
		Random random = new Random();
		CSVExporter t = new CSVExporter();
		List<ctwedge.util.Test> tempTsActs = ts1.getTests();
		int nToBeRemoved = (int) (tempTsActs.size() * (percentage / 100.0));
		// Remove nToBeRemoved tests
		for (int j = 0; j < nToBeRemoved; j++) {
			tempTsActs.remove(random.nextInt(tempTsActs.size()));
		}
		// Save the test suite to file
		String csvCode = toCSVcode(tempTsActs);
		TestSuite tsTemp;
		if (!csvCode.equals(""))
			tsTemp = new TestSuite(csvCode, model, ",");
		else
			tsTemp = new TestSuite(model, null);
		t.generateOutput(tsTemp, TEMP_FILE_NAME);
		return tempTsActs;
	}
	
	/**
	 * Given a test suite, a model and a percentage of parameter values to be removed from each test case, it
	 * randomly removes values
	 * 
	 * @param model      the CIT Model
	 * @param ts1        the test suite from which test values need to be removed
	 * @param percentage the percentage of parameters to be removed
	 * @return a list of Tests
	 */
	private List<ctwedge.util.Test> randomlyAddDontCares(CitModel model, TestSuite ts1, int percentage) {
		Random random = new Random();
		CSVExporter t = new CSVExporter();
		List<ctwedge.util.Test> tempTsActs = ts1.getTests();
		int nToBeRemoved = (int) (model.getParameters().size() * (percentage / 100.0));
		
		// For each test case, remove randomly nToBeRemoved values
		for (int i=0; i<ts1.getTests().size(); i++) {
			ArrayList<Integer> indexes = new ArrayList<>();
			for (int j=0; j<model.getParameters().size(); j++)
				indexes.add(j);
			
			for (int j = 0; j < nToBeRemoved; j++) {
				int index = random.nextInt(indexes.size());
				ts1.getTests().get(i).put(model.getParameters().get(indexes.get(index)).getName(), "*");
				indexes.remove(index);
			}
		}
		
		// Save the test suite to file
		String csvCode = toCSVcode(ts1.getTests());
		TestSuite tsTemp;
		if (!csvCode.equals(""))
			tsTemp = new TestSuite(csvCode, model, ",");
		else
			tsTemp = new TestSuite(model, null);
		t.generateOutput(tsTemp, TEMP_FILE_NAME);
		return tempTsActs;
	}

	/**
	 * Returns a test suite generated with PICT
	 * 
	 * @param model    the CIT Model
	 * @param strength the strength
	 * @param seed     the test suite to be used as seeds. It can be null if no
	 *                 seeds have to be used
	 * @return a test suite generated with PICT
	 */
	private TestSuite getPICTTestSuite(CitModel model, int strength, TestSuite seed) throws Exception {
		TestSuite ts1;
		ExecutorService executor = Executors.newCachedThreadPool();
		Callable<TestSuite> task = new Callable<TestSuite>() {
			public TestSuite call() throws Exception {
				PICTGenerator pictGenerator = new PICTGenerator();
				TestSuite ts1 = pictGenerator.getTestSuite(model, strength, false, seed);
				ts1.setGeneratorName("PICT");
				return ts1;
			}
		};
		Future<TestSuite> future = executor.submit(task);
		try {
			ts1 = future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
			ts1.setStrength(strength);
		} catch (TimeoutException | InterruptedException | ExecutionException ex) {
			if (System.getProperty("os.name").startsWith("Windows"))
				Runtime.getRuntime().exec("taskkill /F /IM pict.exe");
			else
				Runtime.getRuntime().exec("killall pict");
			ts1 = new TestSuite(model, null);
			ts1.setGeneratorName("PICT");
			ts1.setGeneratorTime(-1);
		} finally {
			// May or may not desire this
			future.cancel(true);
		}
		return ts1;
	}

	/**
	 * Convert a list of tests in a string, for those generators which require the
	 * seeds to be expressed in thee CSV format
	 * 
	 * @param input the list of tests
	 * @return a string with the CSV representation of the list of tests
	 */
	private String toCSVcode(List<ctwedge.util.Test> input) {
		String s = "";
		if (input.size() > 0) {
			int i = 0;
			for (Entry<String, String> assignment : input.get(0).entrySet()) {
				if (i > 0) {
					s += "," + assignment.getKey();
				} else {
					s += assignment.getKey();
				}
				i++;
			}
			s += "\n";
			i = 0;
			for (ctwedge.util.Test test : input) {
				i = 0;
				for (Entry<String, String> assignment : test.entrySet()) {
					if (i > 0) {
						s += "," + assignment.getValue();
					} else {
						s += assignment.getValue();
					}
					i++;
				}
				s += "\n";
			}
		}
		return s;
	}

	/**
	 * Prints statistics to file
	 * 
	 * @param t           the test suite
	 * @param percentage  the removal percentage of test cases
	 * @param strength    the strength
	 * @param output_file the output file name
	 * @param o           the used order (it may be null)
	 * @throws IOException
	 */
	public void printStats(TestSuite t, int percentage, int strength, String output_file, Order o) throws IOException {
		FileWriter fw = new FileWriter(output_file, true);
		BufferedWriter bw = new BufferedWriter(fw);
		String out = "";

		if (t == null || t.getTests() == null)
			out = t.getGeneratorName() + "," + t.getModel().getName() + "," + percentage + ",0," + t.getGeneratorTime()
					+ "," + strength + "," + (o.toString() == null ? "" : o.toString()) + ",";
		else
			out = t.getGeneratorName() + "," + t.getModel().getName() + "," + percentage + "," + t.getTests().size()
					+ "," + t.getGeneratorTime() + "," + strength + "," + (o == null ? "" : o.toString()) + ",";

		bw.write(out);
		bw.newLine();
		bw.close();
	}

	/**
	 * Generates a test suite with pMEDICI+
	 * 
	 * @param f          the file containing the model in CTWedge format
	 * @param tempTsActs the seeds
	 * @param strength   the strength
	 * @return the test suite generated with pMEDICI+
	 * @throws IOException
	 * @throws InterruptedException
	 */
	private TestSuite getPMediciPlusTestSuite(File f, List<ctwedge.util.Test> tempTsActs, int strength)
			throws IOException, InterruptedException {
		TestSuite tsTemp;
		ExecutorService executor = Executors.newCachedThreadPool();
		Callable<TestSuite> task = new Callable<TestSuite>() {
			public TestSuite call() throws Exception {
				PMedici pMEDICI = new PMedici();
				TestSuite tsTemp;
				List<ctwedge.util.Test> tempTs;
				pMEDICI.setSeeds(tempTsActs);
				TestSuite ts2 = pMEDICI.generateTests(f.getAbsolutePath(), strength, 0);
				tempTs = ts2.getTests();
				tempTs = tempTs.stream().distinct().collect(Collectors.toList());
				tsTemp = new TestSuite(toCSVcode(tempTs), Utility.loadModelFromPath(f.getAbsolutePath()), ",");
				tsTemp.setGeneratorName("pMEDICI+");
				tsTemp.setGeneratorTime(ts2.getGeneratorTime());
				return tsTemp;
			}
		};
		Future<TestSuite> future = executor.submit(task);
		try {
			tsTemp = future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
		} catch (TimeoutException | InterruptedException | ExecutionException ex) {
			tsTemp = new TestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), null);
			tsTemp.setGeneratorName("pMEDICI+");
			tsTemp.setGeneratorTime(-1);
		} finally {
			// May or may not desire this
			future.cancel(true);
		}
		return tsTemp;
	}

	/**
	 * Generates a test suite with pMEDICI
	 * 
	 * @param f          the file containing the model in CTWedge format
	 * @param tempTsActs the seeds. They are appended to the original test suite in
	 *                   order to keep them
	 * @param strength   the strength
	 * @return the test suite generated with pMEDICI
	 * @throws IOException
	 * @throws InterruptedException
	 */
	private TestSuite getPMediciTestSuite(File f, List<ctwedge.util.Test> tempTsActs, int strength)
			throws IOException, InterruptedException {
		TestSuite tsTemp;
		ExecutorService executor = Executors.newCachedThreadPool();
		Callable<TestSuite> task = new Callable<TestSuite>() {
			public TestSuite call() throws Exception {
				PMedici pMEDICI = new PMedici();
				List<ctwedge.util.Test> tempTs;
				TestSuite tsTemp;
				pMEDICI.setOldTs("");
				TestSuite ts3 = pMEDICI.generateTests(f.getAbsolutePath(), strength, 0);
				// Add the tests of the previous test suite and remove duplicates
				long start = System.currentTimeMillis();
				if (tempTsActs != null)
					ts3.getTests().addAll(tempTsActs);
				tempTs = ts3.getTests();
				tempTs = tempTs.stream().distinct().collect(Collectors.toList());
				tsTemp = new TestSuite(toCSVcode(tempTs), Utility.loadModelFromPath(f.getAbsolutePath()), ",");
				tsTemp.setGeneratorName("pMEDICI");
				tsTemp.setGeneratorTime(ts3.getGeneratorTime() + (System.currentTimeMillis() - start));
				return tsTemp;
			}
		};
		Future<TestSuite> future = executor.submit(task);
		try {
			tsTemp = future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
		} catch (TimeoutException | InterruptedException | ExecutionException ex) {
			tsTemp = new TestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), null);
			tsTemp.setGeneratorName("pMEDICI");
			tsTemp.setGeneratorTime(-1);
		} finally {
			// May or may not desire this
			future.cancel(true);
		}
		return tsTemp;
	}

	/**
	 * Executes the TSCP Scenario with pMEDICI and pMEDICI+, and performs
	 * experiments using different types of ordering
	 * 
	 * @param output_file the name of the output file in which the results are
	 *                    written
	 * @param f           the file containing the ctwedge model
	 * @param percentage  the removal percentage of test cases from original test
	 *                    suite
	 * @param tempTsActs  the seeds
	 * @throws IOException
	 * @throws InterruptedException
	 */
	private void getAllPMediciTestSuites(String output_file, File f, int percentage, List<ctwedge.util.Test> tempTsActs)
			throws IOException, InterruptedException {
		TestSuite tsTemp;
		for (Order o : Order.values()) {
			// Ordering strategy
			PMedici.order = o;

			// --------------------------------
			// INCREMENTAL APPROACH - pMEDICI +
			// --------------------------------
			// Load the test suite into pMEDICI+ and generate the new test suite
			// incrementally
			tsTemp = getPMediciPlusTestSuite(f, tempTsActs, STRENGTH);
			printStats(tsTemp, percentage, STRENGTH, output_file, o);
			Thread.sleep(200);
			// --------------------------------
			// TRADITIONAL APPROACH - pMEDICI
			// --------------------------------
			// Generate the test suite from scratch with pMEDICI
			tsTemp = getPMediciTestSuite(f, tempTsActs, STRENGTH);
			printStats(tsTemp, 0, STRENGTH, output_file, o);
			Thread.sleep(200);
		}
	}

	/**
	 * Executes the SINC Scenario with pMEDICI and pMEDICI+, and performs
	 * experiments using different types of ordering
	 * 
	 * @param output_file the name of the output file in which the results are
	 *                    written
	 * @param f           the file containing the ctwedge model
	 * @param tempTsActs  the seeds
	 * @throws IOException
	 * @throws InterruptedException
	 */
	private void getAllPMediciTestSuitesSINC(String output_file, File f, TestSuite tempTsActs)
			throws IOException, InterruptedException {
		TestSuite tsTemp;
		for (Order o : Order.values()) {
			// Ordering strategy
			PMedici.order = o;

			// Try with pMEDICI with seeds (pMEDICI+)
			tsTemp = getPMediciPlusTestSuite(f, tempTsActs.getTests(), STRENGTH + 1);
			printStats(tsTemp, 0, STRENGTH + 1, output_file, o);

			// Try with pMEDICI without seeds (pMEDICI)
			tsTemp = getPMediciTestSuite(f, null, STRENGTH + 1);
			printStats(tsTemp, 100, STRENGTH + 1, output_file, o);
		}
	}

	/**
	 * Test executor for the SINC Scenario.
	 * 
	 * It executes the tests with: - ACTS (without seeds) - ACTS (with seeds) -
	 * pMEDICI (without seeds) - pMEDICI+ (with seeds) - PICT (with seeds) - PICT
	 * (without seeds)
	 * 
	 * First a complete test suite is generated for strength t by pMEDICI, then this
	 * is used by the other tools as seed
	 * 
	 * @throws Exception
	 */
	@Test
	public void testSINC() throws Exception {
		File folder = new File(PATH);
		File[] listOfFiles = folder.listFiles();
		Arrays.sort(listOfFiles, new Comparator<File>() {
			@Override
			public int compare(File o1, File o2) {
				return o1.getName().compareTo(o2.getName());
			}
		});
		String timeStamp = new SimpleDateFormat("yyyy.MM.dd.HH.mm").format(new java.util.Date());
		String output_file = "resultsSINC_"+ timeStamp + ".csv";

		// File header
		printFileHeader(output_file);

		// Configurations
		TestContext.IN_TEST = true;

		for (File f : listOfFiles) {
			if (!f.getAbsolutePath().endsWith(".ctw") || ! f.getName().contains("C_"))
				continue;

			// Repeat the experiments N_REP times
			for (int i = 0; i < N_REP; i++) {

				// Generate test suite with strength t=2 with ACTS
				TestSuite ts1 = null;
				try {
					ts1 = getACTSTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH, null);
					printStats(ts1, 0, STRENGTH, output_file, null);
				} catch (Error | Exception e) {
					continue;
				}

				// Proceed only if seeds have been generated
				if (ts1.getGeneratorTime() != -1) {
					// Define the seeds
					TestSuite tsTempPICT;
					TestSuite tsTempACTS;

					// Try with PICT with seeds
					tsTempPICT = getPICTTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH + 1, ts1);
					tsTempPICT.setGeneratorName("PICT w SEEDS");
					printStats(tsTempPICT, 0, STRENGTH + 1, output_file, null);

					// Try with PICT without seeds
					tsTempPICT = getPICTTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH + 1, null);
					printStats(tsTempPICT, 100, STRENGTH + 1, output_file, null);

					// Try with ACTS with seeds
					tsTempACTS = getACTSTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH + 1, ts1);
					tsTempACTS.setGeneratorName("ACTS w SEEDS");
					printStats(tsTempACTS, 0, STRENGTH + 1, output_file, null);

					// Try with ACTS without seeds
					tsTempACTS = getACTSTestSuite(Utility.loadModelFromPath(f.getAbsolutePath()), STRENGTH + 1, null);
					printStats(tsTempACTS, 100, STRENGTH + 1, output_file, null);

					// Try with pMEDICI and pMEDICI+ with multiple ordering strategies
					getAllPMediciTestSuitesSINC(output_file, f, ts1);
				}
			}
		}
	}

	/**
	 * Test executor for the TCCP (Test Cases Completion) Scenario
	 * @throws Exception 
	 */
	@Test
	public void testTCCP() throws Exception {
		File folder = new File(PATH);
		File[] listOfFiles = folder.listFiles();
		Arrays.sort(listOfFiles, new Comparator<File>() {
			@Override
			public int compare(File o1, File o2) {
				return o1.getName().compareTo(o2.getName());
			}
		});
		String timeStamp = new SimpleDateFormat("yyyy.MM.dd.HH.mm").format(new java.util.Date());
		String output_file = "resultsTCCP_"+ timeStamp + ".csv";

		// File header
		printFileHeader(output_file);

		// Configurations
		TestContext.IN_TEST = true;

		for (File f : listOfFiles) {
			if (!f.getAbsolutePath().endsWith(".ctw"))
				continue;
			CitModel model = Utility.loadModelFromPath(f.getAbsolutePath());
			CitModel modelACTS = Utility.loadModelFromPath(f.getAbsolutePath());

			// Repeat the experiments N_REP times
			for (int i = 0; i < N_REP; i++) {

				// Generate test suite with ACTS
				TestSuite ts1 = null;
				try {
					ts1 = getACTSTestSuite(modelACTS, STRENGTH, null);
					printStats(ts1, 0, STRENGTH, output_file, null);
				} catch (Error e) {
					System.err.println(e.getMessage());
					continue;
				}

				// Proceed only if seeds have been generated
				if (ts1.getGeneratorTime() != -1) {
					// Remove a percentage of test cases and define a new test suite
					for (int percentage : PERCENTAGE_REMOVAL) {
						System.out.println("---- Removing " + percentage + " %");
						// Define the seeds
						TestSuite tsTemp;
						TestSuite tsTempPICT;
						TestSuite tsTempACTS;
						List<ctwedge.util.Test> tempTsActs = randomlyAddDontCares(model, ts1, percentage);
						if (tempTsActs.size() > 0)
							tsTemp = new TestSuite(toCSVcode(tempTsActs), model, ",");
						else
							tsTemp = null;

						// Try with PICT
						System.out.println("---- PICT with " + percentage + " %");
						tsTempPICT = getPICTTestSuite(model, STRENGTH, tsTemp);
						printStats(tsTempPICT, percentage, STRENGTH, output_file, null);

						// Try with ACTS by feeding a seed test suite
						System.out.println("---- ACTS with " + percentage + " %");
						tsTempACTS = getACTSTestSuite(modelACTS, STRENGTH, tsTemp);
						printStats(tsTempACTS, percentage, STRENGTH, output_file, null);

						// Try with pMEDICI and pMEDICI+ with multiple ordering strategies
						System.out.println("---- pMEDICI with " + percentage + " %");
						getAllPMediciTestSuites(output_file, f, percentage, tempTsActs);
					}
				}
			}
		}
	}
}
